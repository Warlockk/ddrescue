\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ddrescue.info
@settitle GNU ddrescue
@finalout
@c %**end of header

@set UPDATED 17 November 2008
@set VERSION 1.9

@dircategory GNU Packages
@direntry
* ddrescue: (ddrescue).         Data recovery tool.
@end direntry


@titlepage
@title GNU ddrescue
@subtitle Data recovery tool
@subtitle for ddrescue version @value{VERSION}, @value{UPDATED}
@author by Antonio Diaz Diaz

@page
@vskip 0pt plus 1filll
@end titlepage

@contents

@node Top
@top

This manual is for GNU ddrescue (version @value{VERSION}, @value{UPDATED}).

@menu
* Introduction::	Purpose and features of GNU ddrescue
* Algorithm::		How ddrescue recovers the data
* Invoking ddrescue::	Command line interface
* Logfile Structure::	Detailed format of the logfile
* Examples::		A small tutorial with examples
* Direct Disc Access::	Bypassing the kernel cache
* Fill Mode::		Selectively overwriting the output file
* Generate Mode::	Generating an approximate logfile
* Problems::		Reporting bugs
* Concept Index::	Index of concepts
@end menu

@sp 1
Copyright @copyright{} 2004, 2005, 2006, 2007, 2008 Antonio Diaz Diaz.

This manual is free documentation: you have unlimited permission
to copy, distribute and modify it.


@node Introduction
@chapter Introduction
@cindex introduction

GNU ddrescue is a data recovery tool. It copies data from one file or
block device (hard disc, cdrom, etc) to another, trying hard to rescue
data in case of read errors.

The basic operation of ddrescue is fully automatic. That is, you don't
have to wait for an error, stop the program, read the log, run it in
reverse mode, etc.

If you use the logfile feature of ddrescue, the data is rescued very
efficiently, (only the needed blocks are read). Also you can interrupt
the rescue at any time and resume it later at the same point.

Automatic merging of backups: If you have two or more damaged copies of
a file, cdrom, etc, and run ddrescue on all of them, one at a time,
with the same output file, you will probably obtain a complete and
error-free file. This is so because the probability of having damaged
areas at the same places on different input files is very low. Using
the logfile, only the needed blocks are read from the second and
successive copies.

Recordable CD and DVD media keep their data only for a finite time
(typically for many years). After that time, data loss develops slowly
with read errors growing from the outer media region towards the inside.
Just make two (or more) copies of every important CD/DVD you burn so
that you can later recover them with ddrescue.

Ddrescue does not truncate the output file if not asked to. So, every
time you run it on the same output file, it tries to fill in the gaps.

Because ddrescue needs to read and write at random places, it only works
on seekable (random access) input and output files.

If your system supports it, ddrescue can use direct disc access to read
the input file, bypassing the kernel cache.

Ddrescue also features a "fill mode" able to selectively overwrite parts
of the output file, which has a number of interesting uses like wiping
data, marking bad areas or even, in some cases, "repair" damaged
sectors.


@node Algorithm
@chapter Algorithm
@cindex algorithm

GNU ddrescue manages efficiently the status of the rescue in progress
and tries to rescue the good parts first, maximizing the amount of data
finally recovered from a failing drive.

The standard dd utility can be used to save data from a failing drive,
but it reads the data secuentially, which may wear out the drive without
rescuing anything if the errors are at the beginning of the drive.

Other programs switch to small size reads when they find errors, but
this is a bad idea because it means spending more time at error areas,
damaging the surface, the heads and the drive mechanics, instead of
getting out of them as fast as possible. This behavior reduces the
chances of rescuing the remaining good data.

The algorithm of ddrescue is as follows: (the user may interrupt the
process at any point)

1) Optionally read a logfile describing the status of a multi-part or
previously interrupted rescue. If no logfile is specified or is empty or
does not exist, mark all the rescue domain as non-tried.

2) Read the non-tried parts of the input file, marking the damaged areas
as non-trimmed and skipping beyond them, until all the rescue domain is
tried.

3) Read backwards the damaged areas marked as non-trimmed until an error
is found, and mark the rest of the area as non-split.

4) Try to read the damaged areas marked as non-split, splitting them
into smaller pieces and reading the non-damaged pieces, until the
hardware block size is reached. Mark the pieces that can't be read as
bad hardware blocks.

5) Try to read the damaged hardware blocks until the specified number
of retries is reached.

6) Optionally write a logfile for later use.

@sp 1
The logfile is periodically saved to disc, as well as when ddrescue
finishes or is interrupted. So in case of a crash you can resume the
rescue with little recopying.

Also, the same logfile can be used for multiple commands that copy
different areas of the file, and for multiple recovery attempts over
different subsets. See this example:

@noindent
Rescue the most important part of the disc first.
@example
ddrescue -i0 -s50M /dev/hdc hdimage logfile
ddrescue -i0 -s1M -r3 -d /dev/hdc hdimage logfile
@end example

@noindent
Then rescue some key disc areas.
@example
ddrescue -i30G -s10G /dev/hdc hdimage logfile
ddrescue -i230G -s5G /dev/hdc hdimage logfile
@end example

@noindent
Now rescue the rest (does not recopy what is already done).
@example
ddrescue /dev/hdc hdimage logfile
ddrescue -r3 -d /dev/hdc hdimage logfile
@end example


@node Invoking ddrescue
@chapter Invoking ddrescue
@cindex invoking
@cindex options
@cindex usage
@cindex version

The format for running ddrescue is:

@example
ddrescue [@var{options}] @var{infile} @var{outfile} [@var{logfile}]
@end example

ddrescue supports the following options:

@table @samp
@item --help
@itemx -h
Print an informative help message describing the options and exit.

@item --version
@itemx -V
Print the version number of ddrescue on the standard output and exit.

@item --block-size=@var{bytes}
@itemx -b @var{bytes}
Hardware block size of input device in bytes (usually 512 for hard discs
and 3.5" floppies, 1024 for 5.25" floppies, and 2048 for cdroms).
Defaults to 512.

@item --binary-prefixes
@itemx -B
Show units with binary prefixes (powers of 1024).@*
SI prefixes (powers of 1000) are used by default. (See table below).

@item --cluster-size=@var{blocks}
@itemx -c @var{blocks}
Number of hardware blocks (sectors) to copy at a time. Defaults to
@w{64KiB / hardware_block_size}. Try smaller values for slow drives. The
number of sectors per track (18 or 9) is a good value for floppies.

@item --complete-only
@itemx -C
Limit rescue domain to the blocks of finite size read from logfile. Do
not read new data beyond logfile limits. This is useful when reading
from devices of undefined size, like raw devices.

@item --direct
@itemx -d
Use direct disc access to read the input file, bypassing the kernel
cache. Hardware block size must be correctly set for this to work. Not
all systems support this.

@item --synchronous
@itemx -D
Use synchronous writes for output file. May be useful when forcing the
drive to remap its bad sectors.

@item --max-errors=@var{n}
@itemx -e @var{n}
Maximum number of error areas allowed before giving up. Defaults to infinity.

@item --fill=@var{types}
@itemx -F @var{types}
Fill the output file areas specified as any of @var{types} in the
logfile, with data read from the input file. @var{types} contains one or
more of the status characters defined in the chapter Logfile Structure
(@pxref{Logfile Structure}). See the chapter Fill Mode (@pxref{Fill
Mode}) for a complete description of the fill mode.

@item --generate-logfile
@itemx -g
Generate an approximate logfile from the input and output files of the
original rescue run. Note that you should keep the original offset
between @samp{--input-position} and @samp{--output-position} of the
original rescue run.

@item --input-position=@var{pos}
@itemx -i @var{pos}
Starting position in input file, in bytes. Defaults to 0. In fill mode
it refers to the original input file. See the chapter Fill Mode
(@pxref{Fill Mode}) for details.

@item --domain-logfile=@var{file}
@itemx -m @var{file}
Restrict the rescue domain to the areas marked as finished in the
logfile @var{file}. This is useful if the destination drive fails during
the rescue.

@item --no-split
@itemx -n
Do not try to split or retry error areas. Allows a fast recovery of the
non-damaged part of the file. This option overrides the
@samp{--max-retries} option.

@item --output-position=@var{pos}
@itemx -o @var{pos}
Starting position in output file, in bytes. Defaults to
@samp{--input-position}. The bytes below @var{pos} aren't touched if
they exist and truncation is not requested. Else they are set to 0.

@item --quiet
@itemx -q
Quiet operation.

@item --max-retries=@var{n}
@itemx -r @var{n}
Exit after given number of retry passes. -1 means infinity. Defaults to
0. Every bad sector is tried only one time per pass. To retry error
areas detected on a previous run, you must specify a non-zero number of
retries.

@item --retrim
@itemx -R
Mark all error areas inside the rescue domain as non-trimmed before
beginning the rescue. The effect is similar to @samp{--max-retries=1},
but the bad sectors are tried in a different order, making perhaps
possible to rescue some of them.

@item --max-size=@var{bytes}
@itemx -s @var{bytes}
Maximum size of data to be copied, in bytes. Note that this parameter
specifies the amount of data to be copied, not the size of the output
file. So, for example, the following command creates an output file 300
bytes long, but only writes data on the last 200 bytes:
@example
ddrescue -i 100 -s 200 infile outfile logfile
@end example

@item --sparse
@itemx -S
Use sparse writes for output file. May save a lot of disc space in some
cases. Not all systems support this.

@item --truncate
@itemx -t
Truncate output file.

@item --verbose
@itemx -v
Verbose mode.

@end table

@sp 1
Numbers given as arguments to options (positions, sizes) may be followed
by a multiplier and an optional @samp{B} for "byte".

Table of SI and binary prefixes (unit multipliers):

@multitable {Prefix} {kilobyte  (10^3 = 1000)} {|} {Prefix} {kibibyte (2^10 = 1024)}
@item Prefix @tab Value               @tab | @tab Prefix @tab Value
@item   @tab                          @tab | @tab b  @tab hardware blocks
@item k @tab kilobyte  (10^3 = 1000)  @tab | @tab Ki @tab kibibyte (2^10 = 1024)
@item M @tab megabyte  (10^6)         @tab | @tab Mi @tab mebibyte (2^20)
@item G @tab gigabyte  (10^9)         @tab | @tab Gi @tab gibibyte (2^30)
@item T @tab terabyte  (10^12)        @tab | @tab Ti @tab tebibyte (2^40)
@item P @tab petabyte  (10^15)        @tab | @tab Pi @tab pebibyte (2^50)
@item E @tab exabyte   (10^18)        @tab | @tab Ei @tab exbibyte (2^60)
@item Z @tab zettabyte (10^21)        @tab | @tab Zi @tab zebibyte (2^70)
@item Y @tab yottabyte (10^24)        @tab | @tab Yi @tab yobibyte (2^80)
@end multitable

@sp 1
NOTE: Don't believe everything Usamericans tell you. 10^9 is a thousand
millions, a billion is a million millions (million^2), a trillion is a
million million millions (million^3), and so on. Please, don't "embrace
and extend" the meaning of prefixes, making communication among all
people difficult. Thanks.


@node Logfile Structure
@chapter Logfile Structure
@cindex logfile structure

The logfile is a text file easy to read and edit. It is formed of two
parts, the status line and the list of data blocks.

NOTE: Logfiles generated by a version of ddrescue prior to 1.6 lack the
status line. If you want to use an old logfile with ddrescue 1.6 or
later, you will have to insert a line like @samp{0 +} at the beginning
of the logfile.

The first non-comment line is the status line. It contains a
non-negative integer and a status character. The integer is the position
being tried in the input file. The status character is one of these:

@multitable {Character} {generating approximate logfile}
@item Character @tab Meaning
@item '?'       @tab copying data
@item '*'       @tab trimming bad areas
@item '/'       @tab splitting bad areas
@item '-'       @tab retrying bad hardware blocks
@item 'F'       @tab filling specified areas
@item 'G'       @tab generating approximate logfile
@item '+'       @tab finished
@end multitable

Every line in the list of data blocks describes a block of data, and
contains 2 non-negative integers and a status character. The first
integer is a position in the input file, the second is the size (in
bytes) of the data to be copied. The status character is one of these:

@multitable {Character} {bad hardware block(s)}
@item Character @tab Meaning
@item '?'       @tab non-tried
@item '*'       @tab bad area non-trimmed
@item '/'       @tab bad area non-split
@item '-'       @tab bad hardware block(s)
@item '+'       @tab finished
@end multitable

@noindent
And here is an example logfile:

@noindent
# Rescue Logfile. Created by GNU ddrescue version @value{VERSION}@*
# current_pos  current_status@*
0x00120000     ?@*
#      pos         size   status@*
@multitable {0x00000000} {0x00000000} {status}
@item 0x00000000 @tab 0x00117000 @tab +
@item 0x00117000 @tab 0x00000200 @tab -
@item 0x00117200 @tab 0x00001000 @tab /
@item 0x00118200 @tab 0x00007E00 @tab *
@item 0x00120000 @tab 0x00048000 @tab ?
@end multitable

Any line beginning with @samp{#} is a comment line. The blocks must be
contiguous and non-overlapping. The size field of the last line is
special. If it is -1 means that the size of the file is undefined and
end of file has not been reached yet.

If you edit the file, you may use decimal, hexadecimal or octal values,
using the same syntax that integer constants in C++.


@node Examples
@chapter A small tutorial with examples
@cindex examples

Ddrescue is like any other power tool. You need to understand what it
does, and you need to understand some things about the machines it does
those things to, in order to use it safely.

A failing drive tends to develop more and more errors as time passes.
Because of this, you should rescue the data from a drive as soon as you
notice the first error.

IMPORTANT! Always use a logfile unless you know you won't need it.
Without a logfile, ddrescue can't resume a rescue, only reinitiate it.

IMPORTANT! Never try to rescue a r/w mounted partition. The resulting
copy may be useless.

You should make a copy of the failing drive with ddrescue, and then try
to repair the copy. If your data is really important, use the first copy
as a master for a second copy, and try to repair the second copy. If
something goes wrong, you have the master intact to try again.

IMPORTANT! Never try to repair a file system on a drive with I/O errors;
you will probably lose even more data.

If you are trying to rescue a whole partition, first repair the copy
with e2fsck or some other tool appropiate for the type of partition you
are trying to rescue, then mount the repaired copy somewhere and try to
recover the files in it.

If the drive is so damaged that the rescued partition can't be repaired
or mounted, you will have to browse the rescued data with an hex editor
and extract the desired parts by hand.

If the partition table is damaged, you may try to rescue the whole disc,
then try to repair the partition table and the partitions on the copy.

If the damaged drive is not listed in /dev, then you cannot rescue it.
At least not with ddrescue.

@sp 1
@noindent
Example 1: Rescue a whole disc with two ext2 partitions in /dev/hda to
/dev/hdb@*
Note: you do not need to partition /dev/hdb beforehand.

@example
ddrescue -n /dev/hda /dev/hdb logfile
ddrescue -dr3 /dev/hda /dev/hdb logfile
fdisk /dev/hdb
e2fsck -v -f /dev/hdb1
e2fsck -v -f /dev/hdb2
@end example

@sp 1
@noindent
Example 2: Rescue an ext2 partition in /dev/hda2 to /dev/hdb2@*
Note: you need to create the hdb2 partition with fdisk first. hdb2
should be of appropiate type and size.

@example
ddrescue -n /dev/hda2 /dev/hdb2 logfile
ddrescue -d -r3 /dev/hda2 /dev/hdb2 logfile
e2fsck -v -f /dev/hdb2
mount -t ext2 -o ro /dev/hdb2 /mnt
read files from /mnt
@end example

@sp 1
@noindent
Example 3: Rescue a CD-ROM in /dev/cdrom

@example
ddrescue -n -b2048 /dev/cdrom cdimage logfile
ddrescue -d -b2048 /dev/cdrom cdimage logfile
write cdimage to a blank CD-ROM
@end example

@sp 1
@noindent
Example 4: While rescuing a whole disc in /dev/hda to /dev/hdb, /dev/hdb
fails and you have to rescue data to a third disc, /dev/hdc

@example
ddrescue -n /dev/hda /dev/hdb logfile1     <-- /dev/hdb fails here
ddrescue -m logfile1 /dev/hdb /dev/hdc logfile2
ddrescue -n /dev/hda /dev/hdc logfile2
ddrescue -dr3 /dev/hda /dev/hdc logfile2
@end example


@node Direct Disc Access
@chapter Direct Disc Access
@cindex direct disc access
@cindex raw devices

If you notice that the sizes and offsets in the log file are ALWAYS
multiples of the hardware block size, maybe your kernel is caching the
disc accesses and grouping them. In this case you may want to use direct
disc access or a raw device to bypass the kernel cache and rescue more
of your data.

NOTE! Hardware block size must be correctly set with the
@samp{--block-size} option for this to work. Try the @samp{--direct}
option first. If direct disc access is not available in your system, try
raw devices. Read your system documentation to find how to bind a raw
device to a regular block device.

Ddrescue aligns its I/O buffer to the hardware block size so that it can
be used for direct disc access or to read from raw devices. For
efficiency reasons, also aligns it to the memory page size if page size
is a multiple of hardware block size. Ddrescue can't determine the size
of a raw device, so a explicit @samp{--max-size} or
@samp{--complete-only} option is needed.

Using direct disc access, or reading from a raw device, may be slower
than normal cached reading for hard discs (but faster for floppies). In
this case you may want to make a first pass using normal cached reads,
and use direct disc access, or a raw device, only to recover the good
sectors inside the error areas.

@sp 1
@noindent
Example 1: using direct disc access

@example
ddrescue -n /dev/hdb1 /dev/hdc1 logfile
ddrescue -d -r3 /dev/hdb1 /dev/hdc1 logfile
e2fsck -v -f /dev/hdc1
mount -t ext2 -o ro /dev/hdc1 /mnt
@end example

@sp 1
@noindent
Example 2: using a raw device

@example
raw /dev/raw/raw1 /dev/hdb1
ddrescue -n /dev/hdb1 /dev/hdc1 logfile
ddrescue -r3 -C /dev/raw/raw1 /dev/hdc1 logfile
raw /dev/raw/raw1 0 0
e2fsck -v -f /dev/hdc1
mount -t ext2 -o ro /dev/hdc1 /mnt
@end example


@node Fill Mode
@chapter Fill Mode
@cindex Fill Mode

When ddrescue is invoked with the @samp{--fill} option it operates in
"fill mode", which is different from the default "rescue mode". That is,
if you use the @samp{--fill} option, ddrescue does not rescue anything.
It only fills with data read from the input file the areas of the output
file whose status character from the logfile coincides with one of the
type characters specified as argument to the @samp{--fill} option.

In fill mode the input file may have any size. If it is too small, the
data will be duplicated as many times as necessary to fill the input
buffer. If it is too big, only the needed data will be read.

Note that in fill mode the input file is always read from position 0. If
you specify a @samp{--input-position}, it refers to the original input
file from which the logfile was built, and is only used to calculate the
offset between input and output positions.

Note also that when filling the input file of the original rescue run
you should set @samp{--input-position} and @samp{--output-position} to
identical values, whereas when filling the output file of the original
rescue run you should keep the original offset between
@samp{--input-position} and @samp{--output-position}.

The @samp{--fill} option implies the @samp{--complete-only} option.

In fill mode the logfile is updated to allow resumability when
interrupted or in case of a crash, but as nothing is being rescued the
logfile is not destroyed. The status line is the only part of the
logfile that is modified.

@sp 1
@noindent
The fill mode has a number of uses. See the following examples:

@noindent
Example 1: Mark parts of the rescued copy to allow finding them when
examined in an hex editor. For example, the following command line fills
all areas marked as @samp{-} (bad hardware blocks) with copies of the
string @w{@samp{BAD BLOCK }}:

@example
echo -n "BAD BLOCK " > tmpfile
ddrescue --fill=- tmpfile outfile logfile
@end example

@noindent
Example 2: Wipe only the good sectors, leaving the bad sectors alone.
This way, the drive will still test bad (i.e., with unreadable sectors).
This is the fastest way of wiping a failing drive, and is specially
useful when sending the drive back to the manufacturer for warranty
replacement.

@example
ddrescue --fill=+ /dev/zero bad_drive logfile
@end example

@noindent
Example 3: Force the drive to remap the bad sectors, making it usable
again. If the drive has only a few bad sectors, and they are not caused
by drive age, you can probably just rewrite those sectors, and the drive
will reallocate them automatically to new "spare" sectors that it keeps
for just this purpose. WARNING! This may not work on your drive.

@example
ddrescue --fill=- --synchronous /dev/zero bad_drive logfile
@end example

@sp 1
@noindent
Fill mode can also help you to figure out, independently of the file
system used, what files are partially or entirely in the bad areas of
the disc. Just follow these steps:

1) Copy the damaged drive with ddrescue until finished. Do not use
sparse writes. This yields a logfile with only finished (@samp{+}) and
bad (@samp{-}) areas.

2) Mount the copied drive (or the image file, via loopback device).

3) Compute a md5sum or other checksum for every file. Build a list of
all the files and their checksums.

4) Fill the bad areas of the copied drive or image file with a byte
value different from zero.

5) Verify the checksums. Those files which have different checksums this
time reside (at least partially) in damaged disk areas.

6) Optionally fill the bad areas of the copied drive or image file with
zeros to restore the disk image.



@node Generate Mode
@chapter Generate-logfile Mode
@cindex Generate-logfile Mode

So you didn't read the tutorial and started ddrescue without a logfile.
Now, two days later, your computer crashed and you can't know how much
data ddrescue managed to save. And even worse, you can't resume the
rescue; you have to restart it from the very beginning.

Or maybe you started copying a drive with @w{@samp{dd
conv=noerror,sync}} and are now in the same situation described above.
In this case, note that you can't use a copy made by dd unless it was
invoked with the @samp{sync} conversion argument.

Don't despair (yet). Ddrescue can in some cases generate an approximate
logfile, from the input file and the (partial) copy, that is almost as
good as an exact logfile. It makes this by simply assuming that sectors
containng all zeros were not rescued.

However, if the destination of the copy was a drive or a partition, (or
an existing regular file and truncation was not requested), most
probably you will need to restart ddrescue from the very beginning.
(This time with a logfile, of course). The reason is that old data may
be present in the drive that have not been overwritten yet, and may be
thus non-tried but non-zero.

For example, if you first tried one of these commands:
@example
ddrescue infile outfile
or
dd if=infile of=outfile conv=noerror,sync
@end example

you can generate an approximate logfile with this command:
@example
ddrescue --generate-logfile infile outfile logfile
@end example


@node Problems
@chapter Reporting Bugs
@cindex bugs
@cindex getting help

There are probably bugs in ddrescue. There are certainly errors and
omissions in this manual. If you report them, they will get fixed. If
you don't, no one will ever know about them and they will remain unfixed
for all eternity, if not longer.

If you find a bug in GNU ddrescue, please send electronic mail to
@email{bug-ddrescue@@gnu.org}. Include the version number, which you can
find by running @w{@samp{ddrescue --version}}.


@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye
